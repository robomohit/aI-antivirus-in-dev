#!/usr/bin/env python3
"""
DOWNLOAD ACTUAL .EXE MALWARE FROM MALWAREBazaar
"""

import os
import sys
import numpy as np
import pickle
from pathlib import Path
import requests
import base64
import json
import time
from colorama import init, Fore, Style

# Initialize colorama
init()

def load_model():
    """Load the real model."""
    try:
        models_dir = "retrained_models"
        model_files = list(Path(models_dir).glob("real_model_*.pkl"))
        metadata_files = list(Path(models_dir).glob("real_metadata_*.pkl"))
        
        if not model_files or not metadata_files:
            print(f"{Fore.RED}‚ùå No real models found!")
            return None, None
        
        latest_model = max(model_files, key=lambda x: x.stat().st_mtime)
        latest_metadata = max(metadata_files, key=lambda x: x.stat().st_mtime)
        
        with open(latest_model, 'rb') as f:
            model = pickle.load(f)
        
        with open(latest_metadata, 'rb') as f:
            metadata = pickle.load(f)
        
        print(f"{Fore.GREEN}‚úÖ Model loaded: {latest_model.name}")
        return model, metadata
        
    except Exception as e:
        print(f"{Fore.RED}‚ùå Error loading model: {e}")
        return None, None

def extract_features(data):
    """Extract features from data."""
    try:
        if len(data) == 0:
            return None
        
        file_size = len(data)
        data_array = np.frombuffer(data, dtype=np.uint8)
        byte_counts = np.bincount(data_array, minlength=256)
        byte_probs = byte_counts / len(data)
        entropy = -np.sum(byte_probs * np.log2(byte_probs + 1e-10))
        
        printable_chars = sum(1 for byte in data if 32 <= byte <= 126)
        printable_ratio = printable_chars / len(data)
        
        strings_count = len([b for b in data if 32 <= b <= 126])
        
        string_lengths = []
        current_string = 0
        for byte in data:
            if 32 <= byte <= 126:
                current_string += 1
            else:
                if current_string > 0:
                    string_lengths.append(current_string)
                    current_string = 0
        avg_string_length = np.mean(string_lengths) if string_lengths else 0
        max_string_length = max(string_lengths) if string_lengths else 0
        
        histogram = np.bincount(data_array, minlength=256)
        histogram_normalized = histogram / len(data)
        histogram_regularity = 1 - np.std(histogram_normalized)
        
        chunk_size = min(1024, len(data) // 10)
        if chunk_size > 0:
            entropies = []
            for i in range(0, len(data), chunk_size):
                chunk = data[i:i+chunk_size]
                if len(chunk) > 0:
                    chunk_array = np.frombuffer(chunk, dtype=np.uint8)
                    chunk_counts = np.bincount(chunk_array, minlength=256)
                    chunk_probs = chunk_counts / len(chunk)
                    chunk_entropy = -np.sum(chunk_probs * np.log2(chunk_probs + 1e-10))
                    entropies.append(chunk_entropy)
            entropy_consistency = 1 - np.std(entropies) if entropies else 0.5
        else:
            entropy_consistency = 0.5
        
        features = {
            'file_size': file_size,
            'entropy': entropy,
            'strings_count': strings_count,
            'avg_string_length': avg_string_length,
            'max_string_length': max_string_length,
            'printable_ratio': printable_ratio,
            'histogram_regularity': histogram_regularity,
            'entropy_consistency': entropy_consistency
        }
        
        return features
        
    except Exception as e:
        print(f"{Fore.RED}‚ùå Error extracting features: {e}")
        return None

def predict(model, metadata, features):
    """Predict using the model."""
    try:
        feature_cols = metadata.get('feature_cols', [])
        feature_array = np.array([features[col] for col in feature_cols]).reshape(1, -1)
        
        probability = model.predict(feature_array, num_iteration=model.best_iteration)[0]
        prediction = 1 if probability > 0.5 else 0
        
        return prediction, probability
        
    except Exception as e:
        print(f"{Fore.RED}‚ùå Prediction error: {e}")
        return 0, 0.5

def get_malwarebazaar_exe_samples():
    """Get .exe malware samples from MalwareBazaar."""
    print(f"{Fore.CYAN}üîÑ Fetching .exe malware samples from MalwareBazaar...")
    
    try:
        # Try the correct MalwareBazaar API endpoint
        url = "https://bazaar.abuse.ch/api/v1/"
        payload = {
            "query": "get_recent",
            "selector": "100"  # Get 100 recent samples
        }
        
        print(f"{Fore.YELLOW}üì° Connecting to MalwareBazaar API...")
        response = requests.post(url, data=payload, timeout=30)
        
        if response.status_code == 200:
            data = response.json()
            if data.get('query_status') == 'ok':
                all_samples = data.get('data', [])
                
                # Filter for .exe files only
                exe_samples = []
                for sample in all_samples:
                    file_type = sample.get('file_type', '').lower()
                    file_name = sample.get('file_name', '').lower()
                    
                    if file_type == 'exe' or file_name.endswith('.exe'):
                        exe_samples.append(sample)
                
                print(f"{Fore.GREEN}‚úÖ Found {len(exe_samples)} .exe malware samples")
                return exe_samples
            else:
                print(f"{Fore.RED}‚ùå Query failed: {data.get('query_status')}")
                return []
        else:
            print(f"{Fore.RED}‚ùå HTTP Error: {response.status_code}")
            return []
            
    except Exception as e:
        print(f"{Fore.RED}‚ùå Error fetching samples: {e}")
        return []

def download_exe_sample(sha256_hash):
    """Download a specific .exe malware sample."""
    try:
        url = "https://bazaar.abuse.ch/api/v1/"
        payload = {
            "query": "get_file",
            "sha256_hash": sha256_hash
        }
        
        response = requests.post(url, data=payload, timeout=30)
        
        if response.status_code == 200:
            data = response.json()
            if data.get('query_status') == 'ok':
                file_content = base64.b64decode(data['data']['file_content'])
                return file_content
            else:
                print(f"{Fore.RED}‚ùå Failed to get file: {data.get('query_status')}")
                return None
        else:
            print(f"{Fore.RED}‚ùå HTTP Error: {response.status_code}")
            return None
            
    except Exception as e:
        print(f"{Fore.RED}‚ùå Error downloading sample: {e}")
        return None

def main():
    """Main function."""
    print(f"{Fore.CYAN}üõ°Ô∏è  DOWNLOAD REAL .EXE MALWARE FROM MALWAREBazaar")
    print(f"{Fore.CYAN}{'='*60}")
    
    # Load model
    print(f"\n{Fore.CYAN}üì¶ Loading model...")
    model, metadata = load_model()
    if not model or not metadata:
        print(f"{Fore.RED}‚ùå Failed to load model!")
        return
    
    # Get .exe malware samples
    exe_samples = get_malwarebazaar_exe_samples()
    
    if not exe_samples:
        print(f"{Fore.RED}‚ùå No .exe samples available from MalwareBazaar!")
        return
    
    # Create test directory
    test_dir = Path("malwarebazaar_exe_downloads")
    test_dir.mkdir(exist_ok=True)
    
    # Test samples
    print(f"\n{Fore.YELLOW}üìä DOWNLOADING AND TESTING REAL .EXE MALWARE:")
    print(f"{Fore.YELLOW}{'='*50}")
    
    results = []
    downloaded_count = 0
    
    # Test first 10 .exe samples
    for i, sample in enumerate(exe_samples[:10]):
        sha256 = sample.get('sha256_hash', '')
        file_type = sample.get('file_type', 'unknown')
        file_name = sample.get('file_name', f'sample_{i}')
        file_size = sample.get('file_size', 0)
        
        print(f"\nüîç Sample {i+1}/10: {file_name}")
        print(f"   Type: {file_type}")
        print(f"   Size: {file_size:,} bytes")
        print(f"   SHA256: {sha256[:16]}...")
        
        # Download the sample
        print(f"   üì• Downloading...")
        file_content = download_exe_sample(sha256)
        
        if file_content:
            # Save the sample
            file_path = test_dir / f"malwarebazaar_exe_{i}_{file_name}"
            
            with open(file_path, 'wb') as f:
                f.write(file_content)
            
            print(f"   üíæ Saved: {file_path}")
            print(f"   üìä Actual size: {len(file_content):,} bytes")
            
            # Test the sample
            print(f"   üîç Analyzing...")
            features = extract_features(file_content)
            
            if features:
                prediction, probability = predict(model, metadata, features)
                
                status = "MALWARE" if prediction == 1 else "BENIGN"
                confidence = probability if prediction == 1 else (1 - probability)
                
                print(f"   ‚úÖ Result: {status} ({confidence:.1%} confidence)")
                print(f"   üìä Entropy: {features['entropy']:.2f}")
                print(f"   üìä Printable ratio: {features['printable_ratio']:.2f}")
                
                results.append({
                    'name': file_name,
                    'type': file_type,
                    'sha256': sha256,
                    'prediction': prediction,
                    'probability': probability,
                    'expected': 1,  # Should be malware
                    'correct': prediction == 1,
                    'features': features,
                    'actual_size': len(file_content)
                })
                
                downloaded_count += 1
            else:
                print(f"   ‚ùå Failed to extract features")
        else:
            print(f"   ‚ùå Failed to download sample")
    
    # Summary
    print(f"\n{Fore.CYAN}{'='*60}")
    print(f"{Fore.CYAN}üìä MALWAREBazaar .EXE DOWNLOAD TEST RESULTS:")
    print(f"{Fore.CYAN}{'='*60}")
    
    print(f"üìä Download Summary:")
    print(f"   .exe samples found: {len(exe_samples)}")
    print(f"   Samples attempted: {len(exe_samples[:10])}")
    print(f"   Successfully downloaded: {downloaded_count}")
    print(f"   Successfully tested: {len(results)}")
    
    if results:
        detected = sum(1 for r in results if r['correct'])
        accuracy = detected / len(results)
        
        print(f"\nüìä Detection Results:")
        print(f"   Samples tested: {len(results)}")
        print(f"   Correctly detected: {detected}")
        print(f"   Detection rate: {accuracy:.1%}")
        
        # Show details for each sample
        print(f"\nüìä Sample Details:")
        for result in results:
            status = "‚úÖ DETECTED" if result['correct'] else "‚ùå MISSED"
            print(f"   {result['name']} ({result['type']}): {status}")
            print(f"      Size: {result['actual_size']:,} bytes, Entropy: {result['features']['entropy']:.2f}")
        
        # Final verdict
        if accuracy > 0.9:
            print(f"\n{Fore.GREEN}‚úÖ EXCELLENT: Model detects real .exe malware!")
            print(f"{Fore.GREEN}   Detection rate: {accuracy:.1%}")
        elif accuracy > 0.8:
            print(f"\n{Fore.YELLOW}‚ö†Ô∏è  GOOD: Model has good detection rate")
            print(f"{Fore.YELLOW}   Detection rate: {accuracy:.1%}")
        elif accuracy > 0.6:
            print(f"\n{Fore.YELLOW}‚ö†Ô∏è  ACCEPTABLE: Model has decent detection rate")
            print(f"{Fore.YELLOW}   Detection rate: {accuracy:.1%}")
        else:
            print(f"\n{Fore.RED}‚ùå POOR: Model needs improvement")
            print(f"{Fore.RED}   Detection rate: {accuracy:.1%}")
    else:
        print(f"\n{Fore.YELLOW}‚ö†Ô∏è  No samples tested successfully")
    
    print(f"\n{Fore.GREEN}üéâ MalwareBazaar .exe download test completed!")
    print(f"{Fore.CYAN}üìÅ Downloaded samples saved in: {test_dir}")

if __name__ == "__main__":
    main()