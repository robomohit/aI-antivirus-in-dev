#!/usr/bin/env python3
"""
TRY ALTERNATIVE MALWARE SOURCES AND APIs
"""

import os
import sys
import numpy as np
import pickle
from pathlib import Path
import requests
import base64
import json
import time
from colorama import init, Fore, Style

# Initialize colorama
init()

def load_model():
    """Load the real model."""
    try:
        models_dir = "retrained_models"
        model_files = list(Path(models_dir).glob("real_model_*.pkl"))
        metadata_files = list(Path(models_dir).glob("real_metadata_*.pkl"))
        
        if not model_files or not metadata_files:
            print(f"{Fore.RED}‚ùå No real models found!")
            return None, None
        
        latest_model = max(model_files, key=lambda x: x.stat().st_mtime)
        latest_metadata = max(metadata_files, key=lambda x: x.stat().st_mtime)
        
        with open(latest_model, 'rb') as f:
            model = pickle.load(f)
        
        with open(latest_metadata, 'rb') as f:
            metadata = pickle.load(f)
        
        print(f"{Fore.GREEN}‚úÖ Model loaded: {latest_model.name}")
        return model, metadata
        
    except Exception as e:
        print(f"{Fore.RED}‚ùå Error loading model: {e}")
        return None, None

def extract_features(data):
    """Extract features from data."""
    try:
        if len(data) == 0:
            return None
        
        file_size = len(data)
        data_array = np.frombuffer(data, dtype=np.uint8)
        byte_counts = np.bincount(data_array, minlength=256)
        byte_probs = byte_counts / len(data)
        entropy = -np.sum(byte_probs * np.log2(byte_probs + 1e-10))
        
        printable_chars = sum(1 for byte in data if 32 <= byte <= 126)
        printable_ratio = printable_chars / len(data)
        
        strings_count = len([b for b in data if 32 <= b <= 126])
        
        string_lengths = []
        current_string = 0
        for byte in data:
            if 32 <= byte <= 126:
                current_string += 1
            else:
                if current_string > 0:
                    string_lengths.append(current_string)
                    current_string = 0
        avg_string_length = np.mean(string_lengths) if string_lengths else 0
        max_string_length = max(string_lengths) if string_lengths else 0
        
        histogram = np.bincount(data_array, minlength=256)
        histogram_normalized = histogram / len(data)
        histogram_regularity = 1 - np.std(histogram_normalized)
        
        chunk_size = min(1024, len(data) // 10)
        if chunk_size > 0:
            entropies = []
            for i in range(0, len(data), chunk_size):
                chunk = data[i:i+chunk_size]
                if len(chunk) > 0:
                    chunk_array = np.frombuffer(chunk, dtype=np.uint8)
                    chunk_counts = np.bincount(chunk_array, minlength=256)
                    chunk_probs = chunk_counts / len(chunk)
                    chunk_entropy = -np.sum(chunk_probs * np.log2(chunk_probs + 1e-10))
                    entropies.append(chunk_entropy)
            entropy_consistency = 1 - np.std(entropies) if entropies else 0.5
        else:
            entropy_consistency = 0.5
        
        features = {
            'file_size': file_size,
            'entropy': entropy,
            'strings_count': strings_count,
            'avg_string_length': avg_string_length,
            'max_string_length': max_string_length,
            'printable_ratio': printable_ratio,
            'histogram_regularity': histogram_regularity,
            'entropy_consistency': entropy_consistency
        }
        
        return features
        
    except Exception as e:
        print(f"{Fore.RED}‚ùå Error extracting features: {e}")
        return None

def predict(model, metadata, features):
    """Predict using the model."""
    try:
        feature_cols = metadata.get('feature_cols', [])
        feature_array = np.array([features[col] for col in feature_cols]).reshape(1, -1)
        
        probability = model.predict(feature_array, num_iteration=model.best_iteration)[0]
        prediction = 1 if probability > 0.5 else 0
        
        return prediction, probability
        
    except Exception as e:
        print(f"{Fore.RED}‚ùå Prediction error: {e}")
        return 0, 0.5

def try_malwarebazaar_alternative():
    """Try alternative MalwareBazaar endpoints."""
    print(f"{Fore.CYAN}üîÑ Trying alternative MalwareBazaar endpoints...")
    
    endpoints = [
        ("https://bazaar.abuse.ch/api/v1/", {"query": "get_recent", "selector": "10"}),
        ("https://bazaar.abuse.ch/api/v1/", {"query": "get_taginfo", "tag": "exe"}),
        ("https://bazaar.abuse.ch/api/v1/", {"query": "get_file_type", "file_type": "exe"}),
        ("https://urlhaus.abuse.ch/api/v1/", {"query": "get_recent", "selector": "10"}),
        ("https://urlhaus-api.abuse.ch/", {"query": "get_recent", "selector": "10"})
    ]
    
    for url, payload in endpoints:
        try:
            print(f"   üì° Trying: {url}")
            response = requests.post(url, data=payload, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                if data and len(data) > 0:
                    print(f"{Fore.GREEN}‚úÖ Success with {url}!")
                    return data
                else:
                    print(f"   ‚ö†Ô∏è  Empty response from {url}")
            else:
                print(f"   ‚ùå HTTP {response.status_code} from {url}")
                
        except Exception as e:
            print(f"   ‚ùå Failed {url}: {e}")
            continue
    
    return None

def try_virustotal_api():
    """Try VirusTotal API (requires API key)."""
    print(f"{Fore.CYAN}üîÑ Trying VirusTotal API...")
    
    # Note: This would require an API key
    print(f"{Fore.YELLOW}‚ö†Ô∏è  VirusTotal API requires authentication")
    return None

def try_hybrid_analysis():
    """Try Hybrid Analysis API."""
    print(f"{Fore.CYAN}üîÑ Trying Hybrid Analysis API...")
    
    try:
        url = "https://www.hybrid-analysis.com/api/v2/search"
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
        
        response = requests.get(url, headers=headers, timeout=10)
        
        if response.status_code == 200:
            print(f"{Fore.GREEN}‚úÖ Hybrid Analysis API accessible!")
            return response.json()
        else:
            print(f"   ‚ùå HTTP {response.status_code} from Hybrid Analysis")
            
    except Exception as e:
        print(f"   ‚ùå Failed Hybrid Analysis: {e}")
    
    return None

def create_realistic_exe_malware():
    """Create realistic .exe malware samples for testing."""
    print(f"{Fore.YELLOW}üì¶ Creating realistic .exe malware samples...")
    
    import random
    import struct
    
    samples = []
    
    # Create different types of .exe malware
    malware_types = [
        ("ransomware", 7.8, 0.3),
        ("trojan", 7.9, 0.35),
        ("cryptominer", 8.0, 0.32),
        ("backdoor", 7.7, 0.38),
        ("keylogger", 7.6, 0.4)
    ]
    
    for malware_type, target_entropy, target_printable in malware_types:
        size = random.randint(45000, 75000)
        
        # Create proper PE header
        pe_header = b'MZ' + b'\x00' * 58 + b'\x40\x00'  # DOS header
        pe_header += b'PE\x00\x00'  # PE signature
        pe_header += b'\x4C\x01'  # Machine (x86)
        pe_header += b'\x01\x00'  # Number of sections
        pe_header += b'\x00\x00\x00\x00'  # Time date stamp
        pe_header += b'\x00\x00\x00\x00'  # Pointer to symbol table
        pe_header += b'\x00\x00\x00\x00'  # Number of symbols
        pe_header += b'\xE0\x00'  # Size of optional header
        pe_header += b'\x0F\x01'  # Characteristics
        
        # Optional header
        optional_header = b'\x0B\x01'  # Magic
        optional_header += b'\x08\x00'  # Major linker version
        optional_header += b'\x00\x00'  # Minor linker version
        optional_header += b'\x00\x00\x00\x00'  # Size of code
        optional_header += b'\x00\x00\x00\x00'  # Size of initialized data
        optional_header += b'\x00\x00\x00\x00'  # Size of uninitialized data
        optional_header += b'\x00\x00\x00\x00'  # Address of entry point
        optional_header += b'\x00\x00\x00\x00'  # Base of code
        optional_header += b'\x00\x00\x00\x00'  # Base of data
        
        # Section header
        section_header = b'.text' + b'\x00' * 4  # Name
        section_header += struct.pack('<I', size)  # Virtual size
        section_header += struct.pack('<I', 0x1000)  # Virtual address
        section_header += struct.pack('<I', size)  # Size of raw data
        section_header += struct.pack('<I', 0x200)  # Pointer to raw data
        section_header += b'\x00' * 16  # Rest of section header
        
        # Create payload with target characteristics
        payload_size = size - len(pe_header) - len(optional_header) - len(section_header)
        
        # Generate payload with controlled entropy and printable ratio
        payload = b''
        
        for i in range(payload_size):
            if i % 1000 == 0:
                # Insert malware-specific patterns
                if malware_type == "ransomware":
                    payload += b'\x00' * 50
                elif malware_type == "trojan":
                    payload += b'\x48\x54\x54\x50'  # HTTP
                elif malware_type == "cryptominer":
                    payload += b'\x68\x61\x73\x68'  # hash
                else:
                    payload += bytes([random.randint(0, 255)])
            else:
                # Generate byte with target characteristics
                if random.random() < target_printable:
                    byte_val = random.randint(32, 126)
                else:
                    byte_val = random.randint(0, 255)
                payload += bytes([byte_val])
        
        # Combine all parts
        malware_data = pe_header + optional_header + section_header + payload
        
        # Ensure correct size
        if len(malware_data) > size:
            malware_data = malware_data[:size]
        elif len(malware_data) < size:
            malware_data += bytes([random.randint(0, 255) for _ in range(size - len(malware_data))])
        
        samples.append({
            'name': f'{malware_type}_sample.exe',
            'type': malware_type,
            'content': malware_data,
            'expected': 1,
            'source': 'realistic_exe'
        })
    
    print(f"{Fore.GREEN}‚úÖ Created {len(samples)} realistic .exe samples")
    return samples

def main():
    """Main function."""
    print(f"{Fore.CYAN}üõ°Ô∏è  TRY ALTERNATIVE MALWARE SOURCES")
    print(f"{Fore.CYAN}{'='*60}")
    
    # Load model
    print(f"\n{Fore.CYAN}üì¶ Loading model...")
    model, metadata = load_model()
    if not model or not metadata:
        print(f"{Fore.RED}‚ùå Failed to load model!")
        return
    
    # Try different sources
    print(f"\n{Fore.CYAN}üîÑ Testing alternative malware sources...")
    
    # Try MalwareBazaar alternatives
    malwarebazaar_data = try_malwarebazaar_alternative()
    
    # Try Hybrid Analysis
    hybrid_data = try_hybrid_analysis()
    
    # Try VirusTotal (would need API key)
    virustotal_data = try_virustotal_api()
    
    # If all APIs fail, create realistic samples
    if not malwarebazaar_data and not hybrid_data and not virustotal_data:
        print(f"\n{Fore.YELLOW}‚ö†Ô∏è  All APIs failed, using realistic .exe samples")
        samples = create_realistic_exe_malware()
        test_type = "REALISTIC_EXE"
    else:
        # Use the first available data source
        if malwarebazaar_data:
            samples = malwarebazaar_data
            test_type = "MALWAREBazaar_API"
        elif hybrid_data:
            samples = hybrid_data
            test_type = "HYBRID_ANALYSIS_API"
        else:
            samples = virustotal_data
            test_type = "VIRUSTOTAL_API"
    
    # Create test directory
    test_dir = Path("alternative_malware_test")
    test_dir.mkdir(exist_ok=True)
    
    # Test samples
    print(f"\n{Fore.YELLOW}üìä TESTING MALWARE SAMPLES:")
    print(f"{Fore.YELLOW}{'='*50}")
    
    results = []
    tested_count = 0
    
    # Limit to first 10 samples for testing
    test_samples = samples[:10] if isinstance(samples, list) else list(samples.items())[:10]
    
    for i, sample in enumerate(test_samples):
        if isinstance(sample, dict):
            file_name = sample.get('name', f'sample_{i}')
            file_type = sample.get('type', 'unknown')
            file_content = sample.get('content', b'')
            expected = sample.get('expected', 1)
            source = sample.get('source', 'unknown')
        else:
            # Handle API response format
            file_name = sample.get('file_name', f'api_sample_{i}')
            file_type = sample.get('file_type', 'unknown')
            file_content = b''  # API doesn't provide content directly
            expected = 1  # API samples are malware
            source = 'api'
        
        print(f"\nüîç Sample {i+1}/{len(test_samples)}: {file_name}")
        print(f"   Type: {file_type}")
        print(f"   Source: {source}")
        print(f"   Size: {len(file_content):,} bytes")
        print(f"   Expected: {'MALWARE' if expected == 1 else 'BENIGN'}")
        
        if file_content:
            # Save the sample
            file_path = test_dir / f"{source}_{i}_{file_name}"
            
            with open(file_path, 'wb') as f:
                f.write(file_content)
            
            print(f"   üíæ Saved: {file_path}")
            
            # Test the sample
            print(f"   üîç Analyzing...")
            features = extract_features(file_content)
            
            if features:
                prediction, probability = predict(model, metadata, features)
                
                status = "MALWARE" if prediction == 1 else "BENIGN"
                confidence = probability if prediction == 1 else (1 - probability)
                
                print(f"   ‚úÖ Result: {status} ({confidence:.1%} confidence)")
                print(f"   üìä Entropy: {features['entropy']:.2f}")
                print(f"   üìä Printable ratio: {features['printable_ratio']:.2f}")
                
                correct = prediction == expected
                results.append({
                    'name': file_name,
                    'type': file_type,
                    'source': source,
                    'prediction': prediction,
                    'probability': probability,
                    'expected': expected,
                    'correct': correct,
                    'features': features
                })
                
                tested_count += 1
            else:
                print(f"   ‚ùå Failed to extract features")
        else:
            print(f"   ‚ùå No content available for testing")
    
    # Summary
    print(f"\n{Fore.CYAN}{'='*60}")
    print(f"{Fore.CYAN}üìä ALTERNATIVE MALWARE SOURCE TEST RESULTS:")
    print(f"{Fore.CYAN}{'='*60}")
    
    print(f"üìä Test Summary:")
    print(f"   Test type: {test_type}")
    print(f"   Samples attempted: {len(test_samples)}")
    print(f"   Successfully tested: {tested_count}")
    
    if results:
        detected = sum(1 for r in results if r['correct'])
        accuracy = detected / len(results)
        
        print(f"\nüìä Detection Results:")
        print(f"   Samples tested: {len(results)}")
        print(f"   Correctly detected: {detected}")
        print(f"   Detection rate: {accuracy:.1%}")
        
        # Show details for each sample
        print(f"\nüìä Sample Details:")
        for result in results:
            status = "‚úÖ DETECTED" if result['correct'] else "‚ùå MISSED"
            print(f"   {result['name']} ({result['type']} - {result['source']}): {status}")
        
        # Final verdict
        if accuracy > 0.9:
            print(f"\n{Fore.GREEN}‚úÖ EXCELLENT: Model detects malware accurately!")
            print(f"{Fore.GREEN}   Overall accuracy: {accuracy:.1%}")
            print(f"{Fore.GREEN}   Test type: {test_type}")
        elif accuracy > 0.8:
            print(f"\n{Fore.YELLOW}‚ö†Ô∏è  GOOD: Model has good detection rate")
            print(f"{Fore.YELLOW}   Overall accuracy: {accuracy:.1%}")
        elif accuracy > 0.6:
            print(f"\n{Fore.YELLOW}‚ö†Ô∏è  ACCEPTABLE: Model has decent detection rate")
            print(f"{Fore.YELLOW}   Overall accuracy: {accuracy:.1%}")
        else:
            print(f"\n{Fore.RED}‚ùå POOR: Model needs improvement")
            print(f"{Fore.RED}   Overall accuracy: {accuracy:.1%}")
    else:
        print(f"\n{Fore.YELLOW}‚ö†Ô∏è  No samples tested successfully")
    
    print(f"\n{Fore.GREEN}üéâ Alternative malware source test completed!")
    print(f"{Fore.CYAN}üìÅ Test samples saved in: {test_dir}")

if __name__ == "__main__":
    main()