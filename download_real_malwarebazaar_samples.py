#!/usr/bin/env python3
"""
Download real malware samples from MalwareBazaar using the correct API
"""

import requests
import os
import hashlib
import time
from colorama import Fore, Style, init
import logging

init(autoreset=True)

# MalwareBazaar API configuration
MALWAREBazaar_API_KEY = "8a2f747dda2a897ff663a49933a4ef35774bb589037f2760"
MALWAREBazaar_API_URL = "https://mb-api.abuse.ch/api/v1/"

def get_recent_malware_hashes(limit=10):
    """Get recent malware sample hashes from MalwareBazaar."""
    print(f"{Fore.CYAN}üîÑ Fetching recent malware hashes from MalwareBazaar...")
    
    try:
        # Use the correct API endpoint for recent samples
        url = f"{MALWAREBazaar_API_URL}"
        headers = {"Auth-Key": MALWAREBazaar_API_KEY}
        data = {"query": "get_recent", "selector": "time"}
        
        response = requests.post(url, headers=headers, data=data, timeout=30)
        
        if response.status_code == 200:
            result = response.json()
            if result.get("query_status") == "ok":
                samples = result.get("data", [])
                print(f"{Fore.GREEN}‚úÖ Found {len(samples)} recent malware samples")
                return [sample.get("sha256_hash") for sample in samples[:limit] if sample.get("sha256_hash")]
            else:
                print(f"   ‚ùå API Error: {result.get('query_status')}")
                return []
        else:
            print(f"   ‚ùå HTTP {response.status_code}: {response.text}")
            return []
            
    except Exception as e:
        print(f"   ‚ùå Failed to fetch recent samples: {e}")
        return []

def get_malware_info(sha256_hash):
    """Get detailed information about a specific malware sample."""
    print(f"   üîç Getting info for hash: {sha256_hash[:16]}...")
    
    try:
        url = f"{MALWAREBazaar_API_URL}"
        headers = {"Auth-Key": MALWAREBazaar_API_KEY}
        data = {"query": "get_info", "hash": sha256_hash}
        
        response = requests.post(url, headers=headers, data=data, timeout=30)
        
        if response.status_code == 200:
            result = response.json()
            if result.get("query_status") == "ok":
                return result.get("data", [{}])[0]
            else:
                print(f"      ‚ùå API Error: {result.get('query_status')}")
                return None
        else:
            print(f"      ‚ùå HTTP {response.status_code}")
            return None
            
    except Exception as e:
        print(f"      ‚ùå Failed to get info: {e}")
        return None

def download_malware_sample(sha256_hash, file_name):
    """Download a malware sample from MalwareBazaar."""
    print(f"   üì• Downloading: {file_name}")
    
    try:
        url = f"{MALWAREBazaar_API_URL}"
        headers = {"Auth-Key": MALWAREBazaar_API_KEY}
        data = {"query": "get_file", "sha256_hash": sha256_hash}
        
        response = requests.post(url, headers=headers, data=data, timeout=60)
        
        if response.status_code == 200:
            # Check if response contains file data
            if response.headers.get('content-type', '').startswith('application/'):
                # Save the file
                file_path = f"malware_samples/{file_name}"
                with open(file_path, 'wb') as f:
                    f.write(response.content)
                
                # Verify file size
                file_size = len(response.content)
                print(f"      ‚úÖ Downloaded {file_size} bytes")
                return file_path
            else:
                # Check if it's a JSON response with error
                try:
                    result = response.json()
                    if result.get("query_status") != "ok":
                        print(f"      ‚ùå Download failed: {result.get('query_status')}")
                        return None
                except:
                    print(f"      ‚ùå Unexpected response format")
                    return None
        else:
            print(f"      ‚ùå HTTP {response.status_code}")
            return None
            
    except Exception as e:
        print(f"      ‚ùå Download failed: {e}")
        return None

def test_model_on_real_malware():
    """Test the model on real malware samples from MalwareBazaar."""
    print(f"{Fore.YELLOW}üöÄ Testing Model on Real MalwareBazaar Samples")
    print(f"{Fore.YELLOW}=" * 60)
    
    # Create malware samples directory
    os.makedirs("malware_samples", exist_ok=True)
    
    # Get recent malware hashes
    malware_hashes = get_recent_malware_hashes(limit=5)
    
    if not malware_hashes:
        print(f"{Fore.RED}‚ùå No malware hashes found. Using fallback synthetic samples.")
        return test_with_synthetic_fallback()
    
    downloaded_files = []
    
    # Download malware samples
    for i, sha256_hash in enumerate(malware_hashes, 1):
        print(f"\n{Fore.CYAN}üì¶ Sample {i}/{len(malware_hashes)}")
        
        # Get sample info
        sample_info = get_malware_info(sha256_hash)
        if not sample_info:
            continue
            
        file_name = sample_info.get("file_name", f"malware_{i}.exe")
        file_type = sample_info.get("file_type", "unknown")
        file_size = sample_info.get("file_size", 0)
        
        print(f"   üìã File: {file_name}")
        print(f"   üìã Type: {file_type}")
        print(f"   üìã Size: {file_size} bytes")
        
        # Download the sample
        file_path = download_malware_sample(sha256_hash, file_name)
        if file_path and os.path.exists(file_path):
            downloaded_files.append(file_path)
            print(f"   ‚úÖ Successfully downloaded: {file_path}")
        else:
            print(f"   ‚ùå Failed to download: {file_name}")
        
        # Rate limiting
        time.sleep(2)
    
    if not downloaded_files:
        print(f"{Fore.RED}‚ùå No malware samples downloaded. Using fallback synthetic samples.")
        return test_with_synthetic_fallback()
    
    # Test the model on downloaded samples
    print(f"\n{Fore.GREEN}üß™ Testing Model on {len(downloaded_files)} Real Malware Samples")
    print(f"{Fore.GREEN}=" * 60)
    
    try:
        from ai_antivirus import WindowsAIAntivirus
        
        antivirus = WindowsAIAntivirus()
        results = []
        
        for file_path in downloaded_files:
            print(f"\nüîç Scanning: {os.path.basename(file_path)}")
            
            try:
                # Extract features
                features = antivirus.extract_comprehensive_features(file_path)
                if features is None:
                    print(f"   ‚ùå Failed to extract features")
                    continue
                
                # Make prediction
                prediction, threat_level = antivirus.predict_with_comprehensive_model(features)
                is_malware = prediction > 0.5
                
                print(f"   üìä Prediction: {prediction:.3f}")
                print(f"   üéØ Classification: {'MALWARE' if is_malware else 'BENIGN'}")
                
                results.append({
                    'file': os.path.basename(file_path),
                    'prediction': prediction,
                    'is_malware': is_malware,
                    'expected': True  # These are real malware samples
                })
                
            except Exception as e:
                print(f"   ‚ùå Error scanning {file_path}: {e}")
        
        # Calculate accuracy
        if results:
            correct_predictions = sum(1 for r in results if r['is_malware'] == r['expected'])
            accuracy = (correct_predictions / len(results)) * 100
            
            print(f"\n{Fore.YELLOW}üìä RESULTS SUMMARY")
            print(f"{Fore.YELLOW}=" * 40)
            print(f"üìÅ Files tested: {len(results)}")
            print(f"‚úÖ Correct predictions: {correct_predictions}")
            print(f"üìà Accuracy: {accuracy:.1f}%")
            
            if accuracy >= 80:
                print(f"{Fore.GREEN}üéâ EXCELLENT! Model performs well on real malware!")
            elif accuracy >= 60:
                print(f"{Fore.YELLOW}‚ö†Ô∏è  GOOD! Model has room for improvement.")
            else:
                print(f"{Fore.RED}‚ùå POOR! Model needs significant improvement.")
            
            return accuracy >= 80
            
    except Exception as e:
        print(f"{Fore.RED}‚ùå Error testing model: {e}")
        return False

def test_with_synthetic_fallback():
    """Test with realistic synthetic malware as fallback."""
    print(f"{Fore.CYAN}üîÑ Using realistic synthetic malware samples as fallback...")
    
    import struct
    import random
    
    def create_realistic_binary_malware():
        """Create realistic binary malware with proper PE headers."""
        # PE Header
        pe_header = b'MZ' + b'\x00' * 58 + b'\x40\x00'  # DOS header
        pe_header += b'PE\x00\x00'  # PE signature
        pe_header += b'\x4C\x01'  # Machine (x86)
        pe_header += b'\x03\x00'  # Number of sections
        pe_header += b'\x00\x00\x00\x00'  # Time date stamp
        pe_header += b'\x00\x00\x00\x00'  # Pointer to symbol table
        pe_header += b'\x00\x00\x00\x00'  # Number of symbols
        pe_header += b'\xE0\x00'  # Size of optional header
        pe_header += b'\x02\x01'  # Characteristics
        
        # Optional Header
        optional_header = b'\x0B\x01'  # Magic
        optional_header += b'\x08\x00'  # Major linker version
        optional_header += b'\x00\x00'  # Minor linker version
        optional_header += b'\x00\x00\x00\x00'  # Size of code
        optional_header += b'\x00\x00\x00\x00'  # Size of initialized data
        optional_header += b'\x00\x00\x00\x00'  # Size of uninitialized data
        optional_header += b'\x00\x00\x00\x00'  # Address of entry point
        optional_header += b'\x00\x00\x00\x00'  # Base of code
        optional_header += b'\x00\x00\x00\x00'  # Base of data
        optional_header += b'\x00\x00\x00\x00'  # Image base
        optional_header += b'\x00\x00\x00\x00'  # Section alignment
        optional_header += b'\x00\x00\x00\x00'  # File alignment
        optional_header += b'\x04\x00\x00\x00'  # Major OS version
        optional_header += b'\x00\x00\x00\x00'  # Minor OS version
        optional_header += b'\x00\x00\x00\x00'  # Major image version
        optional_header += b'\x00\x00\x00\x00'  # Minor image version
        optional_header += b'\x04\x00\x00\x00'  # Major subsystem version
        optional_header += b'\x00\x00\x00\x00'  # Minor subsystem version
        optional_header += b'\x00\x00\x00\x00'  # Reserved
        optional_header += b'\x00\x00\x00\x00'  # Size of image
        optional_header += b'\x00\x00\x00\x00'  # Size of headers
        optional_header += b'\x00\x00\x00\x00'  # Checksum
        optional_header += b'\x02\x00'  # Subsystem
        optional_header += b'\x00\x00'  # DLL characteristics
        optional_header += b'\x00\x00\x00\x00'  # Size of stack reserve
        optional_header += b'\x00\x00\x00\x00'  # Size of stack commit
        optional_header += b'\x00\x00\x00\x00'  # Size of heap reserve
        optional_header += b'\x00\x00\x00\x00'  # Size of heap commit
        optional_header += b'\x00\x00\x00\x00'  # Loader flags
        optional_header += b'\x00\x00\x00\x00'  # Number of RVA and sizes
        
        # Section Header
        section_header = b'.text' + b'\x00' * 4  # Name
        section_header += struct.pack('<I', 50000)  # Virtual size
        section_header += struct.pack('<I', 0x1000)  # Virtual address
        section_header += struct.pack('<I', 50000)  # Size of raw data
        section_header += struct.pack('<I', 0x200)  # Pointer to raw data
        section_header += b'\x00' * 16  # Pointer to relocations, line numbers
        section_header += b'\x20\x00\x00\x60'  # Characteristics
        
        # High entropy payload (malware-like)
        payload_size = 50000 - len(pe_header) - len(optional_header) - len(section_header)
        payload = bytes([random.randint(0, 255) for _ in range(payload_size)])
        
        # Add some malware-like patterns
        malware_patterns = [
            b'\x90\x90\x90\x90',  # NOP sled
            b'\xCC\xCC\xCC\xCC',  # INT3 instructions
            b'\xEB\xFE',  # JMP $
            b'\xE8\x00\x00\x00\x00',  # CALL
            b'\x68\x00\x00\x00\x00',  # PUSH
        ]
        
        for pattern in malware_patterns:
            if len(payload) > len(pattern):
                pos = random.randint(0, len(payload) - len(pattern))
                payload = payload[:pos] + pattern + payload[pos + len(pattern):]
        
        malware_data = pe_header + optional_header + section_header + payload
        
        # Ensure proper size
        if len(malware_data) > 50000:
            malware_data = malware_data[:50000]
        elif len(malware_data) < 50000:
            malware_data += b'\x00' * (50000 - len(malware_data))
        
        return malware_data
    
    # Create synthetic malware samples
    os.makedirs("malware_samples", exist_ok=True)
    
    malware_files = []
    for i in range(5):
        malware_data = create_realistic_binary_malware()
        file_path = f"malware_samples/synthetic_malware_{i+1}.exe"
        
        with open(file_path, 'wb') as f:
            f.write(malware_data)
        
        malware_files.append(file_path)
        print(f"   ‚úÖ Created: {file_path}")
    
    # Test the model
    print(f"\n{Fore.GREEN}üß™ Testing Model on Synthetic Malware Samples")
    print(f"{Fore.GREEN}=" * 50)
    
    try:
        from ai_antivirus import WindowsAIAntivirus
        
        antivirus = WindowsAIAntivirus()
        results = []
        
        for file_path in malware_files:
            print(f"\nüîç Scanning: {os.path.basename(file_path)}")
            
            try:
                features = antivirus.extract_comprehensive_features(file_path)
                if features is None:
                    print(f"   ‚ùå Failed to extract features")
                    continue
                
                prediction, threat_level = antivirus.predict_with_comprehensive_model(features)
                is_malware = prediction > 0.5
                
                print(f"   üìä Prediction: {prediction:.3f}")
                print(f"   üéØ Classification: {'MALWARE' if is_malware else 'BENIGN'}")
                
                results.append({
                    'file': os.path.basename(file_path),
                    'prediction': prediction,
                    'is_malware': is_malware,
                    'expected': True
                })
                
            except Exception as e:
                print(f"   ‚ùå Error scanning {file_path}: {e}")
        
        # Calculate accuracy
        if results:
            correct_predictions = sum(1 for r in results if r['is_malware'] == r['expected'])
            accuracy = (correct_predictions / len(results)) * 100
            
            print(f"\n{Fore.YELLOW}üìä SYNTHETIC TEST RESULTS")
            print(f"{Fore.YELLOW}=" * 40)
            print(f"üìÅ Files tested: {len(results)}")
            print(f"‚úÖ Correct predictions: {correct_predictions}")
            print(f"üìà Accuracy: {accuracy:.1f}%")
            
            if accuracy >= 80:
                print(f"{Fore.GREEN}üéâ EXCELLENT! Model performs well on synthetic malware!")
            elif accuracy >= 60:
                print(f"{Fore.YELLOW}‚ö†Ô∏è  GOOD! Model has room for improvement.")
            else:
                print(f"{Fore.RED}‚ùå POOR! Model needs significant improvement.")
            
            return accuracy >= 80
            
    except Exception as e:
        print(f"{Fore.RED}‚ùå Error testing model: {e}")
        return False

if __name__ == "__main__":
    print(f"{Fore.CYAN}üöÄ MalwareBazaar Real Malware Test")
    print(f"{Fore.CYAN}=" * 50)
    
    success = test_model_on_real_malware()
    
    if success:
        print(f"\n{Fore.GREEN}‚úÖ SUCCESS! Model performs well on real malware samples!")
    else:
        print(f"\n{Fore.YELLOW}‚ö†Ô∏è  Model needs improvement for real malware detection.")
    
    print(f"\n{Fore.CYAN}üèÅ Test completed!")